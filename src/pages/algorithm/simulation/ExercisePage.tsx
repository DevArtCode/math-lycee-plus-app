
import React from 'react';
import { Link } from 'react-router-dom';
import { ArrowLeft, Target } from 'lucide-react';
import { Button } from '@/components/ui/button';
import ExerciseList from '@/components/ExerciseList';

const AlgorithmSimulationExercisePage = () => {
  const exercises = [
    {
      id: "as-1",
      title: "Estimation de π par Monte-Carlo",
      difficulty: "Avancé" as const,
      points: 20,
      statement: "Écrire un algorithme qui estime π en générant des points aléatoires dans un carré contenant un cercle.",
      hint: "Comptez les points à l'intérieur du cercle",
      solution: "import random\nimport math\n\ndef estimer_pi(n_points):\n    \"\"\"Estimation de π par Monte-Carlo\"\"\"\n    points_dans_cercle = 0\n    \n    for _ in range(n_points):\n        x = random.uniform(-1, 1)\n        y = random.uniform(-1, 1)\n        \n        if x*x + y*y <= 1:\n            points_dans_cercle += 1\n    \n    pi_estime = 4 * points_dans_cercle / n_points\n    return pi_estime\n\n# Test\nfor n in [1000, 10000, 100000, 1000000]:\n    pi_approx = estimer_pi(n)\n    erreur = abs(pi_approx - math.pi)\n    print(f\"n={n:7d}: π ≈ {pi_approx:.6f}, erreur = {erreur:.6f}\")",
      explanation: "Méthode de Monte-Carlo pour estimer π en utilisant la géométrie",
      category: "Simulation Monte-Carlo"
    },
    {
      id: "as-2",
      title: "Simulation de lancer de dés",
      difficulty: "Intermédiaire" as const,
      points: 15,
      statement: "Simuler le lancement de deux dés et calculer la fréquence de chaque somme possible.",
      hint: "Les sommes vont de 2 à 12",
      solution: "import random\nfrom collections import Counter\n\ndef simulation_des(n_lancers):\n    \"\"\"Simulation de lancers de deux dés\"\"\"\n    sommes = []\n    \n    for _ in range(n_lancers):\n        de1 = random.randint(1, 6)\n        de2 = random.randint(1, 6)\n        sommes.append(de1 + de2)\n    \n    # Comptage des fréquences\n    frequences = Counter(sommes)\n    \n    print(\"Résultats de la simulation:\")\n    for somme in range(2, 13):\n        freq = frequences[somme] / n_lancers\n        prob_theorique = min(somme-1, 13-somme) / 36\n        print(f\"Somme {somme:2d}: {freq:.4f} (théorique: {prob_theorique:.4f})\")\n    \n    return frequences\n\n# Test\nsimulation_des(10000)",
      explanation: "Simulation de probabilités discrètes avec comparaison théorique",
      category: "Simulation de probabilités"
    },
    {
      id: "as-3",
      title: "Marche aléatoire",
      difficulty: "Intermédiaire" as const,
      points: 18,
      statement: "Simuler une marche aléatoire en 1D et calculer la distance moyenne à l'origine après n pas.",
      hint: "À chaque pas, avancez de +1 ou -1 avec probabilité 1/2",
      solution: "import random\nimport math\n\ndef marche_aleatoire_1d(n_pas, n_simulations=1000):\n    \"\"\"Simulation de marche aléatoire 1D\"\"\"\n    distances_finales = []\n    \n    for _ in range(n_simulations):\n        position = 0\n        for _ in range(n_pas):\n            pas = random.choice([-1, 1])\n            position += pas\n        distances_finales.append(abs(position))\n    \n    distance_moyenne = sum(distances_finales) / len(distances_finales)\n    distance_theorique = math.sqrt(2 * n_pas / math.pi)\n    \n    print(f\"Après {n_pas} pas:\")\n    print(f\"Distance moyenne observée: {distance_moyenne:.4f}\")\n    print(f\"Distance théorique: {distance_theorique:.4f}\")\n    \n    return distances_finales\n\ndef marche_2d(n_pas, n_simulations=1000):\n    \"\"\"Marche aléatoire en 2D\"\"\"\n    distances_finales = []\n    \n    for _ in range(n_simulations):\n        x, y = 0, 0\n        for _ in range(n_pas):\n            direction = random.choice(['N', 'S', 'E', 'W'])\n            if direction == 'N': y += 1\n            elif direction == 'S': y -= 1\n            elif direction == 'E': x += 1\n            else: x -= 1\n        \n        distance = math.sqrt(x*x + y*y)\n        distances_finales.append(distance)\n    \n    distance_moyenne = sum(distances_finales) / len(distances_finales)\n    print(f\"Marche 2D - Distance moyenne: {distance_moyenne:.4f}\")\n    \n    return distances_finales\n\n# Tests\nmarche_aleatoire_1d(100)\nmarche_2d(100)",
      explanation: "Simulation de processus stochastiques (marche aléatoire)",
      category: "Processus stochastiques"
    },
    {
      id: "as-4",
      title: "Problème de Monty Hall",
      difficulty: "Intermédiaire" as const,
      points: 16,
      statement: "Simuler le problème de Monty Hall et comparer les stratégies 'changer' vs 'garder'.",
      hint: "3 portes, 1 voiture, 2 chèvres. L'animateur ouvre une porte avec une chèvre.",
      solution: "import random\n\ndef monty_hall(n_simulations=10000):\n    \"\"\"Simulation du problème de Monty Hall\"\"\"\n    victoires_garder = 0\n    victoires_changer = 0\n    \n    for _ in range(n_simulations):\n        # Configuration: 3 portes, la voiture est derrière une porte aléatoire\n        voiture = random.randint(1, 3)\n        choix_initial = random.randint(1, 3)\n        \n        # L'animateur ouvre une porte avec une chèvre\n        # (différente du choix initial et de la porte avec la voiture)\n        portes = {1, 2, 3}\n        portes.remove(choix_initial)\n        if voiture in portes:\n            portes.remove(voiture)\n        porte_ouverte = random.choice(list(portes))\n        \n        # Nouvelle option de changement\n        portes_restantes = {1, 2, 3}\n        portes_restantes.remove(choix_initial)\n        portes_restantes.remove(porte_ouverte)\n        nouveau_choix = list(portes_restantes)[0]\n        \n        # Compter les victoires\n        if choix_initial == voiture:\n            victoires_garder += 1\n        if nouveau_choix == voiture:\n            victoires_changer += 1\n    \n    prob_garder = victoires_garder / n_simulations\n    prob_changer = victoires_changer / n_simulations\n    \n    print(f\"Résultats sur {n_simulations} simulations:\")\n    print(f\"Probabilité de gagner en gardant: {prob_garder:.4f} (théorique: 0.3333)\")\n    print(f\"Probabilité de gagner en changeant: {prob_changer:.4f} (théorique: 0.6667)\")\n    \n    return prob_garder, prob_changer\n\nmonty_hall()",
      explanation: "Simulation du célèbre problème de probabilité conditionnelle",
      category: "Problèmes classiques"
    },
    {
      id: "as-5",
      title: "Simulation de file d'attente",
      difficulty: "Avancé" as const,
      points: 22,
      statement: "Simuler une file d'attente M/M/1 (arrivées et services exponentiels).",
      hint: "Utilisez des temps d'arrivée et de service aléatoires",
      solution: "import random\nimport math\n\ndef simulation_file_attente(taux_arrivee, taux_service, duree_simulation):\n    \"\"\"Simulation d'une file M/M/1\"\"\"\n    temps_courant = 0\n    temps_fin_service = float('inf')\n    clients_dans_systeme = 0\n    \n    # Statistiques\n    temps_total_attente = 0\n    nb_clients_servis = 0\n    temps_total_occupation = 0\n    \n    # Prochain événement\n    def temps_inter_arrivee():\n        return random.expovariate(taux_arrivee)\n    \n    def temps_service():\n        return random.expovariate(taux_service)\n    \n    prochaine_arrivee = temps_inter_arrivee()\n    \n    while temps_courant < duree_simulation:\n        if prochaine_arrivee < temps_fin_service:\n            # Événement: arrivée\n            temps_courant = prochaine_arrivee\n            clients_dans_systeme += 1\n            \n            if clients_dans_systeme == 1:\n                # Le serveur était libre\n                temps_fin_service = temps_courant + temps_service()\n            \n            prochaine_arrivee = temps_courant + temps_inter_arrivee()\n        \n        else:\n            # Événement: fin de service\n            temps_courant = temps_fin_service\n            clients_dans_systeme -= 1\n            nb_clients_servis += 1\n            \n            if clients_dans_systeme > 0:\n                temps_fin_service = temps_courant + temps_service()\n            else:\n                temps_fin_service = float('inf')\n    \n    # Calcul des métriques\n    rho = taux_arrivee / taux_service\n    temps_attente_theorique = rho / (taux_service * (1 - rho))\n    \n    print(f\"Simulation de file M/M/1:\")\n    print(f\"Taux d'arrivée: {taux_arrivee}, Taux de service: {taux_service}\")\n    print(f\"Utilisation théorique: {rho:.4f}\")\n    print(f\"Temps d'attente théorique: {temps_attente_theorique:.4f}\")\n    print(f\"Clients servis: {nb_clients_servis}\")\n\n# Test\nsimulation_file_attente(taux_arrivee=0.8, taux_service=1.0, duree_simulation=1000)",
      explanation: "Simulation de systèmes de files d'attente",
      category: "Théorie des files"
    },
    {
      id: "as-6",
      title: "Algorithme génétique simple",
      difficulty: "Avancé" as const,
      points: 25,
      statement: "Implémenter un algorithme génétique pour optimiser une fonction simple.",
      hint: "Sélection, croisement, mutation",
      solution: "import random\nimport math\n\ndef algorithme_genetique(fonction_fitness, nb_genes=8, taille_population=50, nb_generations=100):\n    \"\"\"Algorithme génétique simple\"\"\"\n    \n    def creer_individu():\n        return [random.randint(0, 1) for _ in range(nb_genes)]\n    \n    def binaire_vers_decimal(individu):\n        return sum(bit * (2**i) for i, bit in enumerate(reversed(individu)))\n    \n    def selection_tournoi(population, fitness_scores, taille_tournoi=3):\n        participants = random.sample(list(zip(population, fitness_scores)), taille_tournoi)\n        return max(participants, key=lambda x: x[1])[0]\n    \n    def croisement(parent1, parent2):\n        point_croisement = random.randint(1, len(parent1)-1)\n        enfant1 = parent1[:point_croisement] + parent2[point_croisement:]\n        enfant2 = parent2[:point_croisement] + parent1[point_croisement:]\n        return enfant1, enfant2\n    \n    def mutation(individu, prob_mutation=0.01):\n        return [1-bit if random.random() < prob_mutation else bit for bit in individu]\n    \n    # Population initiale\n    population = [creer_individu() for _ in range(taille_population)]\n    \n    for generation in range(nb_generations):\n        # Évaluation\n        fitness_scores = [fonction_fitness(binaire_vers_decimal(ind)) for ind in population]\n        \n        # Statistiques\n        if generation % 20 == 0:\n            best_fitness = max(fitness_scores)\n            avg_fitness = sum(fitness_scores) / len(fitness_scores)\n            print(f\"Génération {generation}: Meilleur={best_fitness:.4f}, Moyenne={avg_fitness:.4f}\")\n        \n        # Nouvelle population\n        nouvelle_population = []\n        \n        for _ in range(taille_population // 2):\n            parent1 = selection_tournoi(population, fitness_scores)\n            parent2 = selection_tournoi(population, fitness_scores)\n            \n            enfant1, enfant2 = croisement(parent1, parent2)\n            enfant1 = mutation(enfant1)\n            enfant2 = mutation(enfant2)\n            \n            nouvelle_population.extend([enfant1, enfant2])\n        \n        population = nouvelle_population\n    \n    # Résultat final\n    fitness_scores = [fonction_fitness(binaire_vers_decimal(ind)) for ind in population]\n    meilleur_individu = population[fitness_scores.index(max(fitness_scores))]\n    meilleure_valeur = binaire_vers_decimal(meilleur_individu)\n    \n    return meilleure_valeur, max(fitness_scores)\n\n# Exemple: maximiser -(x-50)² + 2500 (maximum en x=50)\ndef fitness(x):\n    return -(x - 50)**2 + 2500\n\nmeilleur_x, meilleur_fitness = algorithme_genetique(fitness)\nprint(f\"\\nMeilleure solution: x = {meilleur_x}, fitness = {meilleur_fitness}\")",
      explanation: "Implémentation d'un algorithme génétique pour l'optimisation",
      category: "Algorithmes évolutionnaires"
    },
    {
      id: "as-7",
      title: "Simulation d'épidémie (modèle SIR)",
      difficulty: "Avancé" as const,
      points: 24,
      statement: "Simuler la propagation d'une épidémie avec le modèle SIR (Susceptible-Infecté-Rétabli).",
      hint: "Équations différentielles: dS/dt = -βSI, dI/dt = βSI - γI, dR/dt = γI",
      solution: "import random\nimport math\n\ndef simulation_sir(N, I0, beta, gamma, duree):\n    \"\"\"Simulation du modèle SIR\"\"\"\n    # État initial\n    S = N - I0  # Susceptibles\n    I = I0      # Infectés\n    R = 0       # Rétablis\n    \n    # Historique\n    temps = [0]\n    historique_S = [S]\n    historique_I = [I]\n    historique_R = [R]\n    \n    dt = 0.1  # Pas de temps\n    t = 0\n    \n    while t < duree and I > 0:\n        # Taux de transition\n        taux_infection = beta * S * I / N\n        taux_retablissement = gamma * I\n        \n        # Changements\n        dS = -taux_infection * dt\n        dI = (taux_infection - taux_retablissement) * dt\n        dR = taux_retablissement * dt\n        \n        # Mise à jour\n        S += dS\n        I += dI\n        R += dR\n        t += dt\n        \n        # Enregistrement (tous les 10 pas)\n        if len(temps) % 10 == 0:\n            temps.append(t)\n            historique_S.append(S)\n            historique_I.append(I)\n            historique_R.append(R)\n    \n    # Affichage des résultats clés\n    pic_infectes = max(historique_I)\n    temps_pic = temps[historique_I.index(pic_infectes)]\n    \n    print(f\"Simulation SIR:\")\n    print(f\"Population: {N}, Infectés initiaux: {I0}\")\n    print(f\"β = {beta}, γ = {gamma}, R₀ = {beta/gamma:.2f}\")\n    print(f\"Pic d'infectés: {pic_infectes:.0f} au temps {temps_pic:.1f}\")\n    print(f\"Total final de rétablis: {R:.0f} ({100*R/N:.1f}%)\")\n    \n    return temps, historique_S, historique_I, historique_R\n\n# Version stochastique\ndef simulation_sir_stochastique(N, I0, beta, gamma, duree):\n    \"\"\"Version stochastique du modèle SIR\"\"\"\n    # Population comme liste d'états: 0=S, 1=I, 2=R\n    population = [0] * (N - I0) + [1] * I0\n    \n    historique = [(N-I0, I0, 0)]\n    \n    for jour in range(int(duree)):\n        nouveaux_infectes = 0\n        nouveaux_retablis = 0\n        \n        # Processus d'infection\n        susceptibles = [i for i, etat in enumerate(population) if etat == 0]\n        infectes = [i for i, etat in enumerate(population) if etat == 1]\n        \n        for s in susceptibles:\n            prob_infection = 1 - (1 - beta/N)**len(infectes)\n            if random.random() < prob_infection:\n                population[s] = 1\n                nouveaux_infectes += 1\n        \n        # Processus de rétablissement\n        for i in infectes:\n            if random.random() < gamma:\n                population[i] = 2\n                nouveaux_retablis += 1\n        \n        # Comptage\n        S = population.count(0)\n        I = population.count(1)\n        R = population.count(2)\n        \n        historique.append((S, I, R))\n        \n        if I == 0:\n            break\n    \n    print(f\"\\nVersion stochastique:\")\n    print(f\"Pic d'infectés: {max(h[1] for h in historique)}\")\n    print(f\"Total final de rétablis: {historique[-1][2]}\")\n    \n    return historique\n\n# Tests\nsimulation_sir(N=1000, I0=10, beta=0.3, gamma=0.1, duree=100)\nsimulation_sir_stochastique(N=1000, I0=10, beta=0.3, gamma=0.1, duree=100)",
      explanation: "Modélisation épidémiologique avec approches déterministe et stochastique",
      category: "Modélisation épidémiologique"
    },
    {
      id: "as-8",
      title: "Simulation de portefeuille financier",
      difficulty: "Avancé" as const,
      points: 26,
      statement: "Simuler l'évolution d'un portefeuille d'actions avec le modèle de Black-Scholes.",  
      hint: "dS = μS dt + σS dW où W est un mouvement brownien",
      solution: "import random\nimport math\n\ndef simulation_black_scholes(S0, mu, sigma, T, n_pas, n_simulations=1000):\n    \"\"\"Simulation Monte-Carlo du modèle Black-Scholes\"\"\"\n    dt = T / n_pas\n    prix_finaux = []\n    \n    for _ in range(n_simulations):\n        S = S0\n        for _ in range(n_pas):\n            # Mouvement brownien géométrique\n            dW = random.gauss(0, math.sqrt(dt))\n            dS = mu * S * dt + sigma * S * dW\n            S += dS\n        prix_finaux.append(S)\n    \n    # Statistiques\n    prix_moyen = sum(prix_finaux) / len(prix_finaux)\n    prix_theorique = S0 * math.exp(mu * T)\n    \n    print(f\"Simulation Black-Scholes:\")\n    print(f\"Prix initial: {S0}, μ = {mu}, σ = {sigma}, T = {T}\")\n    print(f\"Prix final moyen: {prix_moyen:.2f}\")\n    print(f\"Prix théorique: {prix_theorique:.2f}\")\n    \n    return prix_finaux\n\ndef simulation_portefeuille(actions, poids, S0_list, mu_list, sigma_list, correlation, T, n_simulations=1000):\n    \"\"\"Simulation d'un portefeuille multi-actifs\"\"\"\n    n_actifs = len(actions)\n    dt = T / 252  # Pas quotidien\n    \n    valeurs_finales = []\n    \n    for _ in range(n_simulations):\n        # Prix initiaux\n        prix = S0_list[:]\n        valeur_portefeuille = sum(p * w for p, w in zip(prix, poids))\n        \n        # Simulation sur T années\n        for jour in range(int(T * 252)):\n            # Génération de chocs corrélés (simplifiée)\n            chocs = [random.gauss(0, math.sqrt(dt)) for _ in range(n_actifs)]\n            \n            # Mise à jour des prix\n            for i in range(n_actifs):\n                dS = mu_list[i] * prix[i] * dt + sigma_list[i] * prix[i] * chocs[i]\n                prix[i] += dS\n            \n            valeur_portefeuille = sum(p * w for p, w in zip(prix, poids))\n        \n        valeurs_finales.append(valeur_portefeuille)\n    \n    # Analyse des risques\n    valeur_moyenne = sum(valeurs_finales) / len(valeurs_finales)\n    valeurs_finales.sort()\n    var_95 = valeurs_finales[int(0.05 * len(valeurs_finales))]\n    \n    valeur_initiale = sum(s * w for s, w in zip(S0_list, poids))\n    \n    print(f\"\\nSimulation de portefeuille:\")\n    print(f\"Valeur initiale: {valeur_initiale:.2f}\")\n    print(f\"Valeur finale moyenne: {valeur_moyenne:.2f}\")\n    print(f\"VaR 95%: {var_95:.2f} (perte max avec 95% de confiance)\")\n    print(f\"Rendement annualisé moyen: {((valeur_moyenne/valeur_initiale)**(1/T) - 1)*100:.2f}%\")\n    \n    return valeurs_finales\n\n# Tests\nprix_finaux = simulation_black_scholes(S0=100, mu=0.05, sigma=0.2, T=1, n_pas=252)\n\n# Portefeuille diversifié\nactions = ['AAPL', 'GOOGL', 'MSFT']\npoids = [0.4, 0.3, 0.3]\nS0_list = [150, 2800, 300]\nmu_list = [0.08, 0.06, 0.07]\nsigma_list = [0.25, 0.20, 0.22]\ncorrelation = 0.3\n\nvaleurs_portefeuille = simulation_portefeuille(actions, poids, S0_list, mu_list, sigma_list, correlation, T=2)",
      explanation: "Simulation financière avec modèles stochastiques",
      category: "Finance quantitative"
    },
    {
      id: "as-9",
      title: "Simulation de réseaux de neurones",
      difficulty: "Avancé" as const,
      points: 28,
      statement: "Implémenter une simulation simple d'apprentissage par réseau de neurones (perceptron).",
      hint: "Mise à jour des poids: w = w + α(y_réel - y_prédit)x",
      solution: "import random\nimport math\n\nclass Perceptron:\n    def __init__(self, n_entrees, taux_apprentissage=0.1):\n        self.poids = [random.uniform(-1, 1) for _ in range(n_entrees + 1)]  # +1 pour le biais\n        self.taux = taux_apprentissage\n    \n    def fonction_activation(self, x):\n        \"\"\"Fonction sigmoïde\"\"\"\n        return 1 / (1 + math.exp(-x))\n    \n    def prediction(self, entrees):\n        \"\"\"Prédiction du perceptron\"\"\"\n        # Ajouter le biais (1) aux entrées\n        entrees_avec_biais = entrees + [1]\n        \n        # Calcul de la somme pondérée\n        somme = sum(w * x for w, x in zip(self.poids, entrees_avec_biais))\n        \n        # Application de la fonction d'activation\n        return self.fonction_activation(somme)\n    \n    def entrainement(self, donnees_entrainement, n_epoques):\n        \"\"\"Entraînement du perceptron\"\"\"\n        for epoque in range(n_epoques):\n            erreur_totale = 0\n            \n            for entrees, cible in donnees_entrainement:\n                # Prédiction\n                prediction = self.prediction(entrees)\n                \n                # Calcul de l'erreur\n                erreur = cible - prediction\n                erreur_totale += erreur ** 2\n                \n                # Mise à jour des poids\n                entrees_avec_biais = entrees + [1]\n                for i in range(len(self.poids)):\n                    self.poids[i] += self.taux * erreur * entrees_avec_biais[i]\n            \n            # Affichage de l'erreur tous les 100 époques\n            if epoque % 100 == 0:\n                erreur_moyenne = erreur_totale / len(donnees_entrainement)\n                print(f\"Époque {epoque}: Erreur moyenne = {erreur_moyenne:.6f}\")\n\ndef generer_donnees_xor(n_exemples):\n    \"\"\"Génère des données pour le problème XOR (non linéairement séparable)\"\"\"\n    donnees = []\n    for _ in range(n_exemples):\n        x1 = random.choice([0, 1])\n        x2 = random.choice([0, 1])\n        y = x1 ^ x2  # XOR\n        donnees.append(([x1, x2], y))\n    return donnees\n\ndef generer_donnees_lineaires(n_exemples):\n    \"\"\"Génère des données linéairement séparables\"\"\"\n    donnees = []\n    for _ in range(n_exemples):\n        x1 = random.uniform(-1, 1)\n        x2 = random.uniform(-1, 1)\n        # Ligne de séparation: x1 + x2 > 0\n        y = 1 if x1 + x2 > 0 else 0\n        donnees.append(([x1, x2], y))\n    return donnees\n\ndef tester_perceptron():\n    \"\"\"Test du perceptron sur différents problèmes\"\"\"\n    print(\"=== Test sur données linéairement séparables ===\")\n    donnees_lineaires = generer_donnees_lineaires(1000)\n    perceptron_lineaire = Perceptron(2, taux_apprentissage=0.1)\n    perceptron_lineaire.entrainement(donnees_lineaires, 500)\n    \n    # Test de prédiction\n    test_points = [[0.5, 0.5], [-0.5, -0.5], [0.8, -0.3], [-0.2, 0.9]]\n    print(\"\\nPrédictions sur points de test:\")\n    for point in test_points:\n        pred = perceptron_lineaire.prediction(point)\n        vraie_classe = 1 if sum(point) > 0 else 0\n        print(f\"Point {point}: prédit={pred:.3f}, vrai={vraie_classe}\")\n    \n    print(\"\\n=== Test sur XOR (problème non linéaire) ===\")\n    donnees_xor = generer_donnees_xor(1000)\n    perceptron_xor = Perceptron(2, taux_apprentissage=0.1)\n    perceptron_xor.entrainement(donnees_xor, 1000)\n    \n    # Test XOR\n    test_xor = [[0, 0], [0, 1], [1, 0], [1, 1]]\n    print(\"\\nPrédictions XOR:\")\n    for point in test_xor:\n        pred = perceptron_xor.prediction(point)\n        vrai_xor = point[0] ^ point[1]\n        print(f\"XOR{point}: prédit={pred:.3f}, vrai={vrai_xor}\")\n    \n    print(\"\\nNote: Le perceptron simple ne peut pas résoudre XOR (non linéairement séparable)\")\n\n# Simulation d'un réseau multi-couches simple\nclass ReseauMultiCouches:\n    def __init__(self, couches):\n        \"\"\"couches: liste du nombre de neurones par couche\"\"\"\n        self.couches = couches\n        self.poids = []\n        \n        # Initialisation des poids entre les couches\n        for i in range(len(couches) - 1):\n            # Matrice de poids entre couche i et i+1\n            w = [[random.uniform(-1, 1) for _ in range(couches[i+1])] \n                 for _ in range(couches[i] + 1)]  # +1 pour le biais\n            self.poids.append(w)\n    \n    def sigmoid(self, x):\n        return 1 / (1 + math.exp(-max(-500, min(500, x))))  # Éviter l'overflow\n    \n    def propagation_avant(self, entrees):\n        \"\"\"Propagation avant\"\"\"\n        activations = [entrees]\n        \n        for couche_poids in self.poids:\n            entrees_avec_biais = entrees + [1]\n            nouvelles_activations = []\n            \n            for j in range(len(couche_poids[0])):\n                somme = sum(entrees_avec_biais[i] * couche_poids[i][j] \n                          for i in range(len(entrees_avec_biais)))\n                nouvelles_activations.append(self.sigmoid(somme))\n            \n            entrees = nouvelles_activations\n            activations.append(entrees)\n        \n        return activations\n    \n    def prediction(self, entrees):\n        \"\"\"Prédiction du réseau\"\"\"\n        activations = self.propagation_avant(entrees)\n        return activations[-1][0]  # Sortie unique\n\n# Test du réseau multi-couches\nprint(\"\\n\" + \"=\"*50)\nprint(\"TEST DU RÉSEAU MULTI-COUCHES\")\nprint(\"=\"*50)\n\n#Configuration: 2 entrées, 3 neurones cachés, 1 sortie\nreseau = ReseauMultiCouches([2, 3, 1])\n\n# Test sur quelques points\npoints_test = [[0, 0], [0, 1], [1, 0], [1, 1]]\nprint(\"Prédictions du réseau multi-couches (avant entraînement):\")\nfor point in points_test:\n    pred = reseau.prediction(point)\n    print(f\"Entrée {point}: sortie = {pred:.3f}\")\n\n# Lancement des tests\ntester_perceptron()",
      explanation: "Simulation d'apprentissage automatique avec réseaux de neurones",
      category: "Intelligence artificielle"
    },
    {
      id: "as-10",
      title: "Simulation de systèmes dynamiques chaotiques",
      difficulty: "Avancé" as const,
      points: 30,
      statement: "Simuler l'attracteur de Lorenz et analyser son comportement chaotique.",
      hint: "Système: dx/dt = σ(y-x), dy/dt = x(ρ-z)-y, dz/dt = xy-βz",
      solution: "import math\n\ndef attracteur_lorenz(sigma=10.0, rho=28.0, beta=8.0/3.0, dt=0.01, n_points=10000):\n    \"\"\"Simulation de l'attracteur de Lorenz\"\"\"\n    # Conditions initiales\n    x, y, z = 1.0, 1.0, 1.0\n    \n    # Historique des points\n    trajectoire = [(x, y, z)]\n    \n    for _ in range(n_points):\n        # Équations de Lorenz\n        dx = sigma * (y - x)\n        dy = x * (rho - z) - y\n        dz = x * y - beta * z\n        \n        # Intégration d'Euler\n        x += dx * dt\n        y += dy * dt\n        z += dz * dt\n        \n        trajectoire.append((x, y, z))\n    \n    return trajectoire\n\ndef analyser_chaos(trajectoire):\n    \"\"\"Analyse des propriétés chaotiques\"\"\"\n    # Calcul de quelques statistiques\n    x_vals = [point[0] for point in trajectoire]\n    y_vals = [point[1] for point in trajectoire]\n    z_vals = [point[2] for point in trajectoire]\n    \n    # Moyennes et écarts-types\n    x_moy = sum(x_vals) / len(x_vals)\n    y_moy = sum(y_vals) / len(y_vals)\n    z_moy = sum(z_vals) / len(z_vals)\n    \n    x_std = math.sqrt(sum((x - x_moy)**2 for x in x_vals) / len(x_vals))\n    y_std = math.sqrt(sum((y - y_moy)**2 for y in y_vals) / len(y_vals))\n    z_std = math.sqrt(sum((z - z_moy)**2 for z in z_vals) / len(z_vals))\n    \n    print(f\"Analyse de l'attracteur de Lorenz:\")\n    print(f\"Moyennes: x̄={x_moy:.3f}, ȳ={y_moy:.3f}, z̄={z_moy:.3f}\")\n    print(f\"Écarts-types: σₓ={x_std:.3f}, σᵧ={y_std:.3f}, σᵤ={z_std:.3f}\")\n    print(f\"Extrema: x∈[{min(x_vals):.2f}, {max(x_vals):.2f}]\")\n    print(f\"         y∈[{min(y_vals):.2f}, {max(y_vals):.2f}]\")\n    print(f\"         z∈[{min(z_vals):.2f}, {max(z_vals):.2f}]\")\n    \n    # Test de sensibilité aux conditions initiales\n    return x_std, y_std, z_std\n\ndef test_sensibilite():\n    \"\"\"Test de la sensibilité aux conditions initiales\"\"\"\n    print(\"\\n=== Test de sensibilité aux conditions initiales ===\")\n    \n    # Deux trajectoires avec conditions initiales légèrement différentes\n    def lorenz_avec_CI(x0, y0, z0, n_points=5000):\n        sigma, rho, beta = 10.0, 28.0, 8.0/3.0\n        dt = 0.01\n        x, y, z = x0, y0, z0\n        points = []\n        \n        for _ in range(n_points):\n            dx = sigma * (y - x)\n            dy = x * (rho - z) - y\n            dz = x * y - beta * z\n            \n            x += dx * dt\n            y += dy * dt\n            z += dz * dt\n            \n            points.append((x, y, z))\n        \n        return points\n    \n    # Conditions initiales très proches\n    traj1 = lorenz_avec_CI(1.0, 1.0, 1.0)\n    traj2 = lorenz_avec_CI(1.0001, 1.0, 1.0)  # Différence de 0.0001\n    \n    # Calcul de la divergence\n    distances = []\n    for i in range(min(len(traj1), len(traj2))):\n        p1, p2 = traj1[i], traj2[i]\n        dist = math.sqrt((p1[0]-p2[0])**2 + (p1[1]-p2[1])**2 + (p1[2]-p2[2])**2)\n        distances.append(dist)\n        \n        # Affichage de quelques points\n        if i % 1000 == 0:\n            print(f\"t={i*0.01:.2f}: distance = {dist:.6f}\")\n    \n    print(f\"Distance finale: {distances[-1]:.6f}\")\n    print(\"Observation: Les trajectoires divergent exponentiellement (chaos!)\")\n\ndef simulation_autres_attracteurs():\n    \"\"\"Simulation d'autres systèmes dynamiques\"\"\"\n    print(\"\\n=== Oscillateur de Van der Pol ===\")\n    \n    def van_der_pol(mu=1.0, dt=0.01, n_points=5000):\n        \"\"\"Oscillateur de Van der Pol: x'' - μ(1-x²)x' + x = 0\"\"\"\n        x, y = 1.0, 0.0  # x et x'\n        trajectoire = [(x, y)]\n        \n        for _ in range(n_points):\n            dx = y\n            dy = mu * (1 - x*x) * y - x\n            \n            x += dx * dt\n            y += dy * dt\n            \n            trajectoire.append((x, y))\n        \n        return trajectoire\n    \n    # Test avec différentes valeurs de μ\n    for mu in [0.1, 1.0, 5.0]:\n        traj = van_der_pol(mu=mu)\n        x_vals = [p[0] for p in traj[-1000:]]  # Derniers 1000 points\n        amplitude = max(x_vals) - min(x_vals)\n        print(f\"μ = {mu}: amplitude du cycle limite = {amplitude:.3f}\")\n\n# Exécution des simulations\nprint(\"SIMULATION DE SYSTÈMES CHAOTIQUES\")\nprint(\"=\" * 50)\n\n# Attracteur de Lorenz\ntrajectoire_lorenz = attracteur_lorenz()\nanalyser_chaos(trajectoire_lorenz)\n\n# Tests de sensibilité\ntest_sensibilite()\n\n# Autres attracteurs\nsimulation_autres_attracteurs()\n\nprint(\"\\nNote: Ces simulations illustrent les propriétés fondamentales du chaos:\")\nprint(\"1. Sensibilité aux conditions initiales\")\nprint(\"2. Comportement non périodique\")\nprint(\"3. Confinement dans un attracteur étrange\")",
      explanation: "Simulation de systèmes dynamiques non-linéaires et analyse du chaos",
      category: "Systèmes dynamiques"
    }
  ];

  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-50 to-orange-50">
      <header className="bg-white/80 backdrop-blur-md border-b border-slate-200">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="flex justify-between items-center h-16">
            <div className="flex items-center space-x-4">
              <Link to="/algorithm">
                <Button variant="ghost" size="sm">
                  <ArrowLeft className="w-4 h-4 mr-2" />
                  Retour aux Algorithmes
                </Button>
              </Link>
              <div className="flex items-center space-x-2">
                <Target className="w-6 h-6 text-orange-600" />
                <h1 className="text-xl font-bold text-slate-900">Exercices - Simulation et Probabilités</h1>
              </div>
            </div>
            <Link to="/algorithm/simulation/course">
              <Button variant="outline">
                Revoir le cours
              </Button>
            </Link>
          </div>
        </div>
      </header>

      <div className="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        <ExerciseList exercises={exercises} color="from-orange-600 to-orange-800" />
      </div>
    </div>
  );
};

export default AlgorithmSimulationExercisePage;
